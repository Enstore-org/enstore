# Kickstart file written by Michael Zalokar & Terry Jones for Enstore.
# $Id$
#

install
lang en_US.UTF-8
langsupport --default en_US.UTF-8 en_US.UTF-8
keyboard us
mouse none
skipx
nfs --server linux.fnal.gov --dir /export/linux/lts305/i386
%include /tmp/network-include
#network --device eth0 --bootproto static --ip 131.225.164.62 --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120 --hostname d0enload.fnal.gov
#network --device eth1 --bootproto dhcp --hostname stkenmvr12a.fnal.gov
rootpw --iscrypted $1$
firewall --disabled
authconfig --enableshadow --enablemd5 --enablekrb5 --krb5realm FNAL.GOV --krb5kdc krb-fnal-1.fnal.gov:88,krb-fnal-2.fnal.gov:88,krb-fnal-3.fnal.gov:88,krb-fnal-4.fnal.gov:88,krb-fnal-5.fnal.gov:88 --krb5adminserver krb-fnal-admin.fnal.gov
timezone America/Chicago
bootloader --location=mbr
# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work
%include /tmp/part-include


#clearpart --all
#part /dos --fstype vfat --start=1 --end=17 --ondisk=hda --onpart=hda1
#part swap --size=512 --start=18 --end=148  --ondisk=hda --onpart=hda2
#part / --fstype ext3 --start=149 --end=671 --ondisk=hda --onpart=hda3
#part /scratch --fstype ext3 --ondisk=hda --size=1 --grow
#part /dos --ondisk=hda --onpart=hda1
#part swap --size=1024 --ondisk=hda --onpart=hda2
#part / --ondisk=hda --onpart=hda3
#part /scratch --ondisk=hda --size=1 --grow
#part /dos --onpart=hda1 --noformat
#part swap --onpart=hda2
#part /  --onpart=hda3
#part /scratch --onpart=hda5

%packages
Fermi-release
GenericFarm-tag
GenericFarm-tree
MAKEDEV
SL_enable_serialconsole
SL_inittab_change
SysVinit
XFree86-Mesa-libGL
XFree86-libs
XFree86-libs-data
Xaw3d
acl
anacron
apmd
ash
at
atk
attr
authconfig
basesystem
bash
bc
beecrypt
bind-libs
bind-utils
binutils
byacc
bzip2
bzip2-libs
chkconfig
compat-db
compat-libstdc++
compat-slang
coreutils
cpio
cpp
cracklib
cracklib-dicts
crontabs
cvs
cyrus-sasl
cyrus-sasl-gssapi
cyrus-sasl-md5
cyrus-sasl-plain
db4
db4-devel
db4-utils
dev
devlabel
dhclient
diffutils
dos2unix
dosfstools
dump
e2fsprogs
e2fsprogs-devel
ed
eject
elfutils
elfutils-libelf
emacs
ethtool
expat
fbset
file
filesystem
findutils
finger
flpr
fontconfig
freetype
ftp
gawk
gcc
gcc-c++
#gcc-java
gd
gdb
gdbm
gdbm-devel
#gettext
ghostscript
glib
glib-devel
glib2
glib2-devel
glibc
glibc-common
glibc-debug
glibc-devel
glibc-headers
glibc-kernheaders
glibc-profile
glibc-utils
gmp
gnupg
gpm
grep
groff
grub
gtk2
gzip
hdparm
hesiod
hotplug
htmlview
hwdata
info
initscripts
iproute
ipsec-tools
iptables
iptables-ipv6
iputils
irda-utils
isdn4k-utils
jfsutils
jwhois
kbd
kernel
kernel-doc
kernel-pcmcia-cs
kernel-smp
kernel-utils
krb5-fermi-config
krb5-libs
krb5-libs-fermi
krb5-workstation
krb5-workstation-fermi
krbafs
kudzu
laus-libs
less
lftp
lha
libacl
libattr
libcap
libdbi
libdbi-devel
libgcc
#libgcj
#libgcj-devel
libjpeg
libpng
libstdc++
libstdc++-devel
libtermcap
libtermcap-devel
libtiff
libtool-libs
libungif
libuser
libwvstreams
libxml2
libxml2-python
lilo
lockdev
logrotate
logwatch
losetup
lslk
lsof
lvm
m4
mailcap
mailx
make
man
man-pages
mdadm
mgetty
mingetty
minicom
mkbootdisk
mkinitrd
mktemp
modutils
mount
mt-st
mtools
mtr
nano
nc
ncompress
ncurses
ncurses-devel
ncurses4
net-tools
netconfig
netdump
newt
nfs-utils
nscd
nss_ldap
ntp
ntsysv
openldap
openssh
openssh-clients
openssl
openssh-server
pam
pam_krb5
pam_smb
pango
parted
passwd
patch
pax
pciutils
pcre
pdksh
perl
perl-Filter
perl-HTML-Parser
perl-HTML-Tagset
perl-URI
perl-libwww-perl
pinfo
pkgconfig
popt
portmap
ppp
prelink
procps
psacct
psmisc
pyOpenSSL
pygtk2
python
python-optik
pyxf86config
quota
raidtools
rdate
rdist
readline
readline-devel
redhat-config-language
redhat-config-mouse
redhat-config-network-tui
redhat-config-securitylevel-tui
redhat-logos
redhat-lsb
redhat-menus
rhnlib
rhpl
rmt
rootfiles
rp-pppoe
rpm
rpm-libs
rpm-python
rsh
rsync
schedutils
sed
sendmail
sendmail-cf
sendmail-devel
sendmail-doc
setarch
setserial
setup
setuptool
shadow-utils
sharutils
slang
slang-devel
slocate
specspo
star
stunnel
sudo
symlinks
sysklogd
syslinux
sysreport
sysstat
talk
tar
tcl
tcp_wrappers
tcpdump
tcsh
telnet
termcap
tftp
time
tmpwatch
traceroute
tzdata
unix2dos
unzip
up2date
upsupdbootstrap
upsupdbootstrap-generic
usbutils
usermode
utempter
util-linux
vconfig
vim-common
vim-minimal
vixie-cron
wget
which
wireless-tools
words
wvdial
xemacs
xinetd
xterm
yp-tools
ypbind
yum
yum-conf
zip
zlib
zlib-devel
zz_cups_nobrowse
zz_dhcp_resolv
zz_fermi-logos
zz_firstboot_fix
zz_lang_collate
zz_logwatch_df
zz_ntp_configure
zz_pine_user_domain
zz_sendmail_fermi_gateway
zz_tcp_wrappers_change
zz_sshd_aklog

%pre
#
# Make the directory where we will locally save the personality of the node.
# This way the kickstart.log will have a home.
#
mkdir -p /tmp/save

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
#
((
#
# Make the directory where we will locally save the personality of the node.
#
echo mkdir -p /tmp/save
mkdir -p /tmp/save
#
# Make the directory where we will remotely save the personality of the node.
#
echo mkdir -p /mnt/tmp
mkdir -p /mnt/tmp
#
# Mount the existing root directory on the node.
#
root_sysimage_count=0
root_sysimage=''
for t in hd sd; do
  for d in a b c d e f g h; do
    for i in 1 2 3 4 5 6 7 8 9; do

	#
	# If we found a disk labeled "/diska" or "/diskc"
	#
	label=`tune2fs -l /dev/$t$d$i | grep "Filesystem volume name:" | cut -c 24-`
	#This is a lazy way to remove whitespace.
	label=`echo $label`

	echo "$label is on /dev/$t$d$i"

	if [ "$label" == "/diska" ]; then
	     echo /dev/$t$d$i > /tmp/diska
	fi
	if [ "$label" == "/diskb" ]; then
	     echo /dev/$t$d$i > /tmp/diskb
	fi
	if [ "$label" == "/diskc" ]; then
	     echo /dev/$t$d$i > /tmp/diskc
	fi

	mount /dev/$t$d$i /mnt/tmp
	rtn1=$?
	# Check not just /dev/hda but also /dev/hda1.  CDROMs will show
	# up with /dev/hdc type names, but will not have any corresponding
	# /dev/hdc1, /dev/hdc2, etc devices.  This should just let disks
	# through (both IDE and SCSI) but exclude CDROMs.
	ls -l /dev/$t$d /dev/${t}${d}1
	rtn2=$?
	if [ "$rtn1" -eq "0" -a "$rtn2" -eq "0" ]; then
	   #Set this here for the case of a blank disk.
	   if [ -z "$root_sysimage" ]; then
	      root_sysimage="/dev/$t$d$i"
	   fi

	   if [ -d /mnt/tmp/etc -o -d /mnt/tmp/usr ]; then
	      echo "Found root file system at device /dev/$t$d$i."
	      root_sysimage="/dev/$t$d$i"
	      let "root_sysimage_count = $root_sysimage_count + 1"
	   fi
	elif [ "$rtn2" -eq "0" ]; then
	   #Set this here for the case of a blank disk.
	   if [ -z "$root_sysimage" ]; then
	      root_sysimage="/dev/$t$d$i"
	   fi
	fi
	if [ "$rtn1" ]; then
	   umount /mnt/tmp
	fi
    done
  done
done
#
# Write out the include file that will contain the disk "part"ition
# information.  Also, mount the disk to use.
#
if [ "$root_sysimage_count" -eq "1" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" ]; then
   abort_install "No sysimage found.  Aborting install."
else
   abort_install "Too many sysimages found.  Aborting install."
fi
if [ -n "$which_disk" ]; then
   echo "part /dos --onpart=${which_disk}1 --noformat" >> /tmp/part-include
   echo "part swap --onpart=${which_disk}2" >> /tmp/part-include
   echo "part /  --onpart=${which_disk}3" >> /tmp/part-include
   echo "part /scratch --onpart=${which_disk}5" >> /tmp/part-include

   echo /dev/$which_disk >> /tmp/which_disk
else
   abort_install "System disk not found.  Aborting install."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	#if [ ! -f "$1" -a ! -d "$1" ]; then
	#	return 2;
	#fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	abort_install "Unable to backup file $1.  Aborting install."

	return 1; # Not reached.
}
#
#
((
#
#
copy_it /mnt/tmp/etc/fstab /tmp/save
copy_it /mnt/tmp/etc/passwd /tmp/save
copy_it /mnt/tmp/etc/shadow /tmp/save
copy_it /mnt/tmp/etc/group /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth0 /tmp/save
if [ -f /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth1 ]; then
	copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth1 /tmp/save
fi
copy_it /mnt/tmp/etc/krb5.keytab /tmp/save
copy_it /mnt/tmp/root/.k5login /tmp/save/root.k5login
copy_it /mnt/tmp/home/enstore/.k5login /tmp/save/enstore.k5login
copy_it /mnt/tmp/fnal/ups/kt/enstorekt /tmp/save
copy_it /mnt/tmp/etc/rc.d/rc.local /tmp/save
if [ -f /mnt/tmp/usr/etc/pnfsSetup ]; then
	copy_it /mnt/tmp/usr/etc/pnfsSetup /tmp/save
fi
if [ -f /mnt/tmp/etc/conserver.cf ]; then
	copy_it /mnt/tmp/etc/conserver.cf /tmp/save
fi
if [ -f /mnt/tmp/usr/local/bin/cons ]; then
	copy_it /mnt/tmp/usr/local/bin/cons /tmp/save
fi
if [ -f /mnt/tmp/etc/exports ]; then
	copy_it /mnt/tmp/etc/exports /tmp/save
fi
if [ -d /mnt/tmp/var/spool/cron ]; then
   cd /mnt/tmp/var/spool
   echo "Taring /var/spool/cron"
   tar cz cron > /tmp/save/cron_ks.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring crons."
   fi
fi
if [ -d /mnt/tmp/root ]; then
   cd /mnt/tmp
   echo "Taring /root"
   tar cz root > /tmp/save/root_ks.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring root."
   fi
fi
if [ -d /mnt/tmp/home ]; then
   cd /mnt/tmp
   echo "Taring /home"
   tar cz home > /tmp/save/home_ks.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring home."
   fi
fi
if [ -d /mnt/tmp/home/enstore/isa-tools]; then
   cd /mnt/tmp/home/enstore
   echo "Taring /home/enstore/isa-tools"
   tar cz isa-tools > /tmp/save/isa-tools.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring isa-tools."
   fi
fi
if [ -f /mnt/tmp/usr/local/bin/netserver]; then
   cd /mnt/tmp/usr/local/bin
   echo "Taring netperf"
   tar cz /mnt/tmp/usr/local/bin/netperf /mnt/tmp/etc/xinetd.d/netperf /mnt/tmp/usr/local/share/info/netperf.info /mnt/tmp/usr/local/share/man/man1/netperf.1 /mnt/tmp/usr/local/etc/netperf.xinetd /mnt/tmp/usr/local/bin/netserver > /tmp/save/netperf_ks.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring netperf
   fi
fi
if [ -d /mnt/tmp/fnal/ups/prd/httpd/cgi-bin/ ]; then
   cd /mnt/tmp/fnal/ups/prd/httpd
   echo "Taring /fnal/ups/prd/httpd/cgi-bin/"
   tar cz cgi-bin > /tmp/save/cgi-bin_ks.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring cgi-bin."
   fi
fi
if [ -d /mnt/tmp/usr/lib/mirror ]; then
   copy_it /mnt/tmp/usr/lib/mirror /tmp/save
fi
cd /

#
# Record what got copied.
#
echo "What got copied."
ls -lh /tmp/save

) 2>&1 ) | tee -a /tmp/save/kickstart.log


%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
get_cluster ( )
{
echo "222222222222222" >> /tmp/save/kickstart.log
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			;;
		cdfen*)
			system=cdfen
			;;
		d0en*)
			system=d0en
			;;
		eagpnfs*)
			system=stken
			;;
		cmspnfs*)
			system=stken
			;;
		gccen*)
			system=gccen
			;;
		*)
			system=""
			;;
	esac

    fi

echo "33333 $system 33333" >> /tmp/save/kickstart.log
    echo $system
}

get_type ( )
{
echo "444444444444444444" >> /tmp/save/kickstart.log
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		eagpnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		cmspnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		gccen*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			;;
		srv*)
			type=srv
			;;
		dm*)
			type=dm
			;;
		load*)
			type=""
			;;
		dca*)
			type=dca
			;;
		pnfs*)
			type=pnfs
			;;
		*)
			type=""
			;;
	esac
    fi

echo "55555555555555555" >> /tmp/save/kickstart.log
    echo $type
}

get_number ( )
{
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		eagpnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		cmspnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		gccen*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		dm*)
			type=dm
			number=`echo $rest | cut -c 3-`
			;;
		dca*)
			type=dca
			number=`echo $rest | cut -c 4-`
			;;
		pnfs*)
			type=pnfs
			number=`echo $rest | cut -c 5-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac
    fi

    echo $number
}
#
#
((
#
#
echo "  Determining hostname information."
#
# parse the host name
#
DOMAIN=".fnal.gov"
hostname1=`grep HOSTNAME /tmp/netinfo | cut -c 10- | cut -f 1 -d "."`
ip1=`grep IPADDR /tmp/netinfo | cut -c 8-`
hostname2=`grep HOSTNAME /tmp/save/network | cut -c 10- | cut -f 1 -d "."`
ip2=`grep IPADDR /tmp/save/ifcfg-eth0 | cut -c 8-`

echo "hostname debugging" >> /tmp/save/test.log
echo "hostname1:" "$hostname1" >> /tmp/save/test.log
echo "cluster of hostname1:" `get_cluster $hostname1` >> /tmp/save/test.log
echo "type of hostname1:" `get_type $hostname1` >> /tmp/save/test.log
echo "number of hostname1:" `get_number $hostname1` >> /tmp/save/test.log
echo "hostname2:" "$hostname2" >> /tmp/save/test.log
echo "cluster of hostname2:" `get_cluster $hostname2` >> /tmp/save/test.log
echo "type of hostname2:" `get_type $hostname2` >> /tmp/save/test.log
echo "number of hostname2:" `get_number $hostname2` >> /tmp/save/test.log

#Search in the order of the:
# 1) The ip that the node was told to use (by either the kickstart or
#    overridden by the user at the install boot prompt).
# 2) The contents of the pre-existing /etc/sysconfig/network file.
echo "1111111111111111" >> /tmp/save/kickstart.log
if [ -n `get_cluster $hostname1` -a -n `get_type $hostname1` ]; then
echo "666666666666666" >> /tmp/save/kickstart.log
   #If the contents of /tmp/netinfo have the real hostname (because
   # the user specified one on the kickstart command line), then use it.
   # What this really means is that if the $hostname1 is a *load.fnal.gov
   # name we will NOT take this branch.

   echo "$hostname1" >> /tmp/save/kickstart.log
   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (1)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

   hostname ${hostname1}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

elif [ -n `get_cluster $hostname2` -a -n `get_type $hostname2` ]; then

   #If the user did not give an ip but the node had an existing name,
   # we will use the existing name.

   # echo the host information
   echo `get_cluster $hostname2` > /tmp/system_name
   echo `get_type $hostname2` > /tmp/type_name
   echo `get_number $hostname2` > /tmp/number_name
   echo "$hostname2" > /tmp/host_name

   echo "Using existing nodename." >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname2}${DOMAIN} --bootproto static --ip $ip2" | tee -a /tmp/network-include

   hostname ${hostname2}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

else

   #If the contents of /tmp/netinfo have the fake hostname, then use it
   # since that is all we've got.

   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (2)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

   hostname ${hostname1}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

fi
echo "Done with network configuration."
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
#
# Check that there exists all the necessary personality files.
#
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
check_for_backup ( )
{
	targets=$1
	shift

	for target in $targets; do
		echo "checking for $target backup" | tee -a /tmp/save/kickstart.log
		for dname in $*; do
			if [ -f $dname/$target -o -d $dname/$target ]; then
				return 0;
			fi
		done
	done

	abort_install "Backup of $target not found.  Aborting install."

	return 1;  #Never reached.
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	if [ ! -f "$1" -a ! -d "$1" ]; then
		return 2;
	fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	echo "Unable to backup file $1.  Aborting install." | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done

	return 1; # Not reached.
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
echo "$hostname" >> /tmp/save/kickstart.log
#
# Mounting 'srv3' backup disk
#
if [ "$system" = "stken" ]; then
        srv3_ip=131.225.13.3
elif [ "$system" = "d0en" ]; then
        srv3_ip=131.225.164.23
elif [ "$system" = "cdfen" ]; then
        srv3_ip=131.225.215.5
elif [ "$system" = "gccen" ]; then
        srv3_ip=131.225.13.3
else
        echo "Hostname not set."
	exit 1
fi
#
#
((
mkdir -p /mnt/backup
if [ -n "$srv3_ip" -a "$type" == "srv" -a "$number" == "3" ]; then
	echo "  Mounting local /diskc for backup."

	mkdir /mnt/backup
	if [ ! -f /tmp/diskc ]; then
	       abort_install "Unable to find LABEL=/diskc to make backups."
	fi
        mount `cat /tmp/diskc` /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
else
	echo "  Mounting ${system}srv3 backup disk for backup."
	mkdir /mnt/backup
	#service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
	#service portmap stop
	df -h
fi
mount
) 2>&1 ) | tee -a /tmp/save/kickstart.log
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
#pulldown_dir="/mnt/backup/backup/"
pulldown_dir="/mnt/backup/backup/kickstart"
#
# Backing up personality.
#
((
if [ -n "$system" -a -n "$type" -a -n "$number" ]; then
   echo "Backing up personality."
   mkdir -p $backup_dir
   for file in `ls $save_dir`; do
       if [ ! -f $backup_dir/$file -o $save_dir/$file -nt $backup_dir/$file ]
       then
	     copy_it $save_dir/$file $backup_dir/$file
       fi
   done
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log


#
# Before continueing with the install.  Make sure that we have the personality
# stored away.
#
echo "Checking the consistancy of the personality backup." | tee -a /tmp/save/kickstart.log
# Only be this picky for nodes that we know who they are and that there
# was a single root filesystem already found (mounted at /mnt/tmp, otherwise
# /mnt/tmp should not exist).
if [ -n "$system" -a -n "$type" -a -n "$number" \
     -a -d /mnt/tmp ]; then
	check_for_backup fstab $save_dir $backup_dir
	check_for_backup passwd $save_dir $backup_dir $pulldown_dir
	check_for_backup shadow $save_dir $backup_dir $pulldown_dir
	check_for_backup group $save_dir $backup_dir $pulldown_dir
	check_for_backup network $save_dir $backup_dir $pulldown_dir
	check_for_backup ifcfg-eth0 $save_dir $backup_dir $pulldown_dir
	check_for_backup krb5.keytab $save_dir $backup_dir
	#check_for_backup root.k5login $save_dir $backup_dir $pulldown_dir
	#check_for_backup enstore.k5login $save_dir $backup_dir $pulldown_dir
	check_for_backup enstorekt $save_dir $backup_dir
	check_for_backup rc.local $backup_dir $pulldown_dir
	if [ \( "$system" == "stken" -o "$system" == "cdfen" -o \
	        "$system" == "d0en" \) -a "$type" == "srv" \
	        -a \( "$number" == "5" -o "$number" == "7" \) ]
	then
		#Only worry about these on console servers.
		check_for_backup conserver.cf $save_dir $backup_dir $pulldown_dir
		check_for_backup cons $save_dir $backup_dir $pulldown_dir
	fi
	check_for_backup "cron_ks.tar.gz cron.tar.gz" $save_dir $backup_dir
	check_for_backup "root_ks.tar.gz root.tar.gz" $save_dir $backup_dir
	check_for_backup "home_ks.tar.gz home.tar.gz" $save_dir $backup_dir
fi


#
#We are done with this mount.
#
cd /
sync
umount /mnt/backup
rm -r /mnt/backup

###) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
cd /
sync
umount /mnt/tmp


%pre
#
#Put this assignment outside any ( ) redirections.
#
disk_device=`cat /tmp/which_disk`
#
#
((
#
#Formating the disk.
#
echo "Formating the disk." | tee -a /tmp/save/kickstart.log
dd if=/dev/zero of=$disk_device bs=512 count=1
#
) 2>&1 ) | tee -a /tmp/save/kickstart.log
##
fdisk $disk_device <<EOF | tee -a /tmp/save/kickstart.log
n
p
1

+128M

n
p
2

+4104M

t
1
6

t
2
82

n
p
3

+10240M

a
3

n
e



n



n




w
q
EOF

#
((
echo "`date +%H:%M:%S`    -[ new partition table on $disk_device: ]-"
fdisk -l $disk_device | grep "^/dev/" | sed -e "s/^/       /"

mkdosfs ${disk_device}1
mkswap ${disk_device}2
#mke2fs ${disk_device}3
#mke2fs ${disk_device}5
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Move information from the /tmp area of the install area to that of the
# installed sysimage.
#

# These are the personality backups.
mkdir /mnt/sysimage/tmp/save
cp -p /tmp/save/* /mnt/sysimage/tmp/save

#These files contain information about networking/hostname information.
cp -p /tmp/netinfo /mnt/sysimage/tmp    #If the old image was lost.
cp -p /tmp/system_name /mnt/sysimage/tmp/
cp -p /tmp/type_name /mnt/sysimage/tmp/
cp -p /tmp/number_name /mnt/sysimage/tmp/
cp -p /tmp/host_name /mnt/sysimage/tmp/
cp -p /tmp/diska /mnt/sysimage/tmp/
cp -p /tmp/diskb /mnt/sysimage/tmp/
cp -p /tmp/diskc /mnt/sysimage/tmp/
cat /mnt/sysimage/tmp/save/network | tee -a /mnt/sysimage/tmp/save/test.log

%post
#We need to put in additional nameservers.
((
grep -v nameserver /etc/resolv.conf > /etc/resolv.conf.tmp
echo "nameserver 131.225.8.120" >> /etc/resolv.conf.tmp
echo "nameserver 131.225.17.150" >> /etc/resolv.conf.tmp
mv /etc/resolv.conf.tmp /etc/resolv.conf
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
# Mount the backup/pulldown disk.
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Mounting 'srv3' backup disk
#
if [ "$system" == "stken" ]; then
	srv3_ip=131.225.13.3
elif [ "$system" == "d0en" ]; then
	srv3_ip=131.225.164.23
elif [ "$system" == "cdfen" ]; then
	srv3_ip=131.225.215.5
elif [ "$system" == "gccen" ]; then
	srv3_ip=131.225.13.3
else
	echo "Hostname not set."
fi
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
((
echo "  Mounting ${system}srv3 backup disk for restoring."
mkdir -p /mnt/backup
if [ "$type" == "srv" -a "$number" == "3" ]; then
        mount `cat /tmp/diskc` /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
else
	service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq "0" ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
	service portmap stop
	df -h
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Shortcut variables.
#   $pulldown_dir = The remote directory that some files are downloaded.
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
# Do things specific to each server.
#
if [ "$system" == "stken" -o "$system" == "d0en" -o "$system" == "cdfen" -o "$system" == "gccen" ]; then

   install_rpm_xfsprogs="1" #All nodes get this.

   if [ "$type" == "srv" ]; then

      if [ "$number" == "0" ]; then

	 install_tarball_postgres="1"

      elif [ "$number" == "1" ]; then

	 install_rpm_postgres="1"
	 install_tarball_postgres="1"
	 install_tarball_pnfs="1"
	 install_rpm_java="1"
	 install_tarball_dcache="1"

      elif [ "$number" == "2" ]; then

         install_upd_apache="1"
	 install_rpm_apache="1"
	 install_upd_remedy_api="1"
	 install_rpm_gnuplot="1"
	 install_rpm_imagemagick="1"
	 install_tarball_postgres="1"

      elif [ "$number" == "3" ]; then

         install_rpm_java="1"
	 install_upd_dcache_clients="1"
	 install_rpm_console_server="1"
	 install_rpm_gnuplot="1"
	 install_rpm_imagemagick="1"
	 install_tarball_postgres="1"

      elif [ "$number" == "4" ]; then

         install_tarball_aci="1"

      elif [ "$number" == "5" ]; then

         install_rpm_console_server="1"

      elif [ "$number" == "6" ]; then

         install_tarball_postgres="1"

      elif [ "$number" == "7" ]; then

         install_rpm_console_server="1"

      elif [ "$number" == "8" ]; then

         echo "" > /dev/null

      elif [ "$number" == "9" ]; then

         install_rpm_console_server="1"

      fi
   elif [ "$type" == "pnfs" ]; then
     #These are for extra pnfs servers.
     install_rpm_postgres="1"
     install_tarball_postgres="1"
     install_tarball_pnfs="1"
     install_rpm_java="1"
     install_tarball_dcache="1"
   fi
elif [ "$system" == "rip" ]; then
     #Place rip specific stuff here.
     echo "Performing rip specific installs." | tee -a /tmp/save/kickstart.log
fi

#
#Do the following for all mass storage nodes.
#
install_tarball_python="1"
install_upd_python="1"
install_tarball_ipmi="1"
install_tarball_enstore="1"
install_upd_swig="1"
install_upd_ftt="1"
install_upd_ngop="1"

((
echo "   Extras to install."
echo install_tarball_python=$install_tarball_python
echo install_upd_python=$install_upd_python
echo install_tarball_ipmi=$install_tarball_ipmi
echo install_tarball_enstore=$install_tarball_enstore
echo install_tarball_postgres=$install_tarball_postgres
echo install_tarball_pnfs=$install_tarball_pnfs
echo install_tarball_dcache=$install_tarball_dcache
echo install_tarball_aci=$install_tarball_aci
echo install_upd_swig=$install_upd_swig
echo install_upd_ftt=$install_upd_ftt
echo install_upd_ngop=$install_upd_ngop
echo install_upd_apache=$install_upd_apache
echo install_upd_remedy_api=$install_upd_remedy_api
echo install_rpm_postgres=$install_rpm_postgres
echo install_rpm_java=$install_rpm_java
echo install_rpm_console_server=$install_rpm_console_server
echo install_rpm_apache=$install_rpm_apache
echo install_rpm_gnuplot=$install_rpm_gnuplot
echo install_rpm_imagemagick=$install_rpm_imagemagick
echo install_rpm_xfsprogs=$install_rpm_xfsprogs
echo
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#
#
# Permform the system specific installs.
#
# RPMs go first.
#
# xfsprogs rpm
if [ "$install_rpm_xfsprogs" == "1" ]; then
   additional_rpms="xfsprogs xfsprogs-devel $additional_rpms"
fi
#
# Java
#
if [ "$install_rpm_java" == "1" ]; then
   #In the future these should be installed via yum.

   echo "Installing java rpms." | tee -a /tmp/save/kickstart.log
   ((
   rpm -i $pulldown_dir/j2sdk-1_4_2_10-linux-i586.rpm
   rpm -i $pulldown_dir/jdk-1_5_0_06-linux-i586.rpm

   cd /usr/java
   #THESE WILL NEED TO CHANGE OVER TIME!
   ln -s jdk1.5.0_06 CURRENT
   ln -s j2sdk1.4.2_10 OLD
   chmod 755 /var/spool/mqueue/
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# gnuplot
#
if [ "$install_rpm_gnuplot" == "1" ]; then
   additional_rpms="gnuplot $additional_rpms"
fi
#
# Apache
#
if [ "$install_rpm_apache" == "1" ]; then
   additional_rpms="httpd $additional_rpms"
fi
#
# console_server
#
if [ "$install_rpm_console_server" == "1" ]; then
   ((
   cd /

   mkdir -p /var/log/conserver

   echo "Installing the FarmsConsole-* rpms."
   yum -y -c /etc/yum.conf.contrib install FarmsConsole-tree FarmsConsole-tag
   ) 2>&1 ) | tee -a /tmp/save/yum.log

   additional_rpms="ConsoleServer-tag ConsoleServer-tree $additional_rpms"
   #additional_rpms="FarmsConsole-tree FarmsConsole-tag $additional_rpms"
   additional_rpms="XFree86 kdebase redhat-config-xfree86 $additional_rpms"
fi
#
# ImageMagick
#
if [ "$install_rpm_imagemagick" == "1" ]; then
   additional_rpms="ImageMagick $addixtional_rpms"
fi
#
# postgresql
#
if [ "$install_rpm_postgres" == "1" ]; then
   echo "Installing postgresql rpms." | tee -a /tmp/save/kickstart.log
   ((
   cd $pulldown_dir
   #Hardcoding the version... Yuck.
   rpm -i postgresql-8.1.3-1PGDG.i686.rpm postgresql-libs-8.1.3-1PGDG.i686.rpm postgresql-server-8.1.3-1PGDG.i686.rpm

   #Backup a copy of the rpm installed postgresql boot script.
   cp -p /etc/rc.d/init.d/postgresql /tmp

   #Change references from user postgres to user enstore in the boot script.
   sed 's/chown postgres:postgres/chown enstore:enstore/' /etc/rc.d/init.d/postgresql | sed 's/-l postgres/-l enstore/' > /etc/rc.d/init.d/postgresql-boot && mv /etc/rc.d/init.d/postgresql-boot /etc/rc.d/init.d/postgresql

   cd /
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
#
#
echo "Install these additional rpms:" | tee -a /tmp/save/kickstart.log
echo "$additional_rpms" | tee -a /tmp/save/kickstart.log
#
# Start these updates from contrib area.  It can/will take a while, better
# to start it in parallel with the other updates.  The yum.conf.contrib
# should include all the regular rpm areas too.
#
yum -y -c /etc/yum.conf.contrib install $additional_rpms >> /tmp/save/yum.log &
#
#
# Begginning ups install.
#
#
# Regardless if /fnal or /local is the real directory, set the other one
# to be a symbolic link to it.
if [ -d /local ]; then
	cd /
	ln -s local fnal
elif [ -d /fnal ]; then
	cd /
	ln -s fnal local
fi
#
#
#  By default this file contains three lines, we only want one.
echo "/local/ups/db" > /local/ups/etc/upsdb_list
chmod 0664 /local/ups/etc/upsdb_list
#
#
mkdir -p /root
mkdir -p /home/enstore
chown 5744.6209 /home/enstore
echo "  Beginning ups installs." | tee -a /tmp/save/kickstart.log
. /fnal/ups/etc/setups.sh
setup upd
#
# Apache
#
if [ "$install_upd_apache" == "1" ]; then
   ((
   upd install -G "-c" -c apache | tee -a /tmp/save/kickstart.log
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# remedy_api
#
if [ "$install_upd_remedy_api" == "1" ]; then
   ((
   upd install -G "-c" -c remedy_api
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# dcache_clients
#
if [ "$install_upd_dcache_clients" == "1" ]; then
   ((
   upd install -G "-c" -c dcap
   upd install -G "-c" -c kftp
   upd install -G "-c" -c srmcp
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# swig
#
if [ "$install_upd_swig" == "1" ]; then
   ((
   upd install -G "-c" swig
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# ftt
#
if [ "$install_upd_ftt" == "1" ]; then
   ((
   upd install ftt -G "-c" v2_25
   upd install ftt v2_22
   upd install ftt v2_18
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# upd python
#
if [ "$install_upd_python" == "1" ]; then
   ((
   upd install -q enstore -G "-q " -c python
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
#
# ngop
#
if [ "$install_upd_ngop" == "1" ]; then
   ((
   upd install -G "-c" -c fcslib
   upd install -G "-q agent" -q agent -c ngop
   ups declare -c -f Linux -m v2_1a.table -r ngop/v2_1a/Linux-agent ngop v2_1a
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
chown -R 1342.4525 /fnal/ups
#
#
# Lastly, install the tarballs.
#
# XXX - These tarballs need to come from somewhere.  That will most likely
# be *srv3.  So, this will likely be moved to the next %post section.
#Python
if [ "$install_tarball_python" == "1" ]; then
   echo "Installing python from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/python.tar.gz
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/python_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
# PostgreSQL
if [ "$install_tarball_postgres" == "1" ]; then
   echo "Installing postgres from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/postgres.tar.gz
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/postgres_db.tar.gz

   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
# PNFS
if [ "$install_tarball_pnfs" == "1" ]; then
   echo "Installing pnfs from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/pnfs.tar.gz
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/pnfs_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
# dCache
if [ "$install_tarball_dcache" == "1" ]; then
   ((
   echo "No-op for install of dCache."
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#Enstore
if [ "$install_tarball_enstore" == "1" ]; then
   echo "Installing enstore db from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/enstore_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#IPMI
if [ "$install_tarball_ipmi" == "1" ]; then
   echo "Installing ipmi db from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/ipmi_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi

#We should wait for yum to finish before continuing.
echo "Waiting for yum update/install to complete."
wait


%post
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
#pulldown_dir="/mnt/backup/backup/"
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
#
# Unwinding tar files
#
#
echo "  Unwinding personality tar files." | tee -a /tmp/save/kickstart.log
mkdir /home /home/enstore
chown 5744.6209 /home/enstore

tar_opt="--same-owner --same-permissions --atime-preserve"

cd /
echo " ...home_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/home_ks.tar.gz ]; then
	tar zxf $save_dir/home_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/home_ks.tar.gz ]; then
	tar zxf $backup_dir/home_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/home.tar.gz ]; then
	tar zxf $backup_dir/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/$use_name/$type/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/$type/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/$use_name/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/home.tar.gz ] ; then
	tar zxf $pulldown_dir/home.tar.gz ${tar_opt}
else
	echo "No home[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /var/spool
echo " ...cron_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/cron_ks.tar.gz ]; then
	tar zxf $save_dir/cron_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron_ks.tar.gz ]; then
	tar zxf $backup_dir/cron_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron.tar.gz ]; then
	tar zxf $backup_dir/cron.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/cron.tar.gz ] ; then
	tar zxf $pulldown_dir/cron.tar.gz ${tar_opt}
else
	echo "No cron[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /home/enstore
echo " ...isa-tools.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/isa-tools.tar.gz ]; then
	tar zxf $save_dir/isa-tools.tar.gz ${tar_opt}
elif [ -f $backup_dir/isa-tools.tar.gz ]; then
	tar zxf $backup_dir/isa-tools.tar.gz ${tar_opt}
elif [ -f $backup_dir/isa-tools.tar.gz ]; then
	tar zxf $backup_dir/isa-tools.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/isa-tools.tar.gz ] ; then
	tar zxf $pulldown_dir/isa-tools.tar.gz ${tar_opt}
else
	echo "No isa-tools.tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /
echo " ...netperf_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/netperf_ks.tar.gz ]; then
	tar zxf $save_dir/netperf_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/netperf_ks.tar.gz ]; then
	tar zxf $backup_dir/netperf_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/netperf_ks.tar.gz ]; then
	tar zxf $backup_dir/netperf_ks.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/netperf_ks.tar.gz ] ; then
	tar zxf $pulldown_dir/netperf_ks.tar.gz ${tar_opt}
else
	echo "No netperf_ks.tar.gz  file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /
echo " ...root_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/root_ks.tar.gz ]; then
	tar zxf $save_dir/root_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/root_ks.tar.gz ]; then
	tar zxf $backup_dir/root_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/root.tar.gz ]; then
	tar zxf $backup_dir/root.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/root.tar.gz ] ; then
	tar zxf $pulldown_dir/root.tar.gz ${tar_opt}
else
	echo "No root[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#Update the farmlets so that rgang can be used to fix stuff later.
mkdir -p /usr/local/etc /usr/local/etc/farmlets
cd /usr/local/etc/farmlets
echo " ...farmlets.tar.gz" | tee -a /tmp/save/test.log
tar zxf $pulldown_dir/farmlets.tar.gz | tee -a /tmp/save/kickstart.log

#
# trying to perform a yum update
echo " ...yum update ??? " | tee -a /tmp/save/kickstart.log
yum -y update yum
yum -y update
yum clean all

#Install Java.
cd
if [ "$type" == "srv" -a "$number" == "1" -o "$type" == "pnfs"]; then
   rpm -i $pulldown_dir/j2sdk-1_4_2_10-linux-i586.rpm
   rpm -i $pulldown_dir/jdk-1_5_0_06-linux-i586.rpm
fi
#
# Restoring personality files.
#
echo "  Restoring personality files." | tee -a /tmp/save/kickstart.log

echo "  Installing passwd, shadow and group files."
copy_it $pulldown_dir/passwd /etc
copy_it $pulldown_dir/shadow /etc
copy_it $pulldown_dir/group /etc

copy_it $save_dir/fstab /etc
if [ $? -eq 1 ] ;then
	copy_it $backup_dir/fstab /etc
fi
copy_it $save_dir/krb5.keytab /etc
if [ ! -f /etc/krb5.keytab ] ;then
	copy_it $backup_dir/krb5.keytab /etc
fi

mkdir /fnal /fnal/ups /fnal/ups/kt
copy_it $save_dir/enstorekt /fnal/ups/kt/enstorekt
if [ ! -f /fnal/ups/kt/enstorekt ] ;then
	copy_it $backup_dir/enstorekt /fnal/ups/kt/enstorekt
fi
chown 5744.6209 /fnal/ups/kt/enstorekt
copy_it $pulldown_dir/rc.local /etc/rc.d
if [ $? -eq 1 ] ;then
	copy_it $backup_dir/rc.local /etc/rc.d/rc.local
fi

### Don't clobber the newly generated files anymore.
#copy_it $save_dir/network /etc/sysconfig/network
#if [ $? -eq 1 ] ;then
#	copy_it $backup_dir/network /etc/sysconfig/network
#fi
### Don't clobber the newly generated files anymore.
#copy_it $save_dir/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
#if [ $? -eq 1 ] ;then
#	copy_it $backup_dir/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
#fi

mkdir -p /home/enstore
copy_it $save_dir/enstore.k5login /home/enstore/.k5login
if [ $? -eq 1 ]; then
	copy_it $backup_dir/enstore.k5login /home/enstore/.k5login
fi
chown 5744.6209 /home/enstore/.k5login

copy_it $pulldown_dir/init.d.network /etc/rc.d/init.d/network
chown 0.0 /etc/rc.d/init.d/network

if [ -f $save_dir/pnfsSetup ]; then
	copy_it $save_dir/pnfsSetup /usr/etc/
	chown 0.0 /usr/etc/pnfsSetup
	cd /usr/etc
	ln -s pnfsSetup pnfsSetup.sh
elif [ -f $backup_dir/pnfsSetup ]; then
	copy_it $backup_dir/pnfsSetup /usr/etc/
	chown 0.0 /usr/etc/pnfsSetup
	cd /usr/etc
	ln -s pnfsSetup pnfsSetup.sh
fi

#
# The next two should only apply to console servers.
#
if [ -f $save_dir/conserver.cf ]; then
	copy_it $save_dir/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
elif [ -f $backup_dir/conserver.cf ]; then
	copy_it $backup_dir/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
fi
if [ -f $save_dir/cons ]; then
	copy_it $save_dir/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
elif [ -f $backup_dir/cons ]; then
	copy_it $backup_dir/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
fi

#
# For nfs servers.
#
if [ -f $save_dir/exports ]; then
	copy_it $save_dir/exports /etc
	chown 0.0 /etc/exports
	chmod 0644 /etc/exports
fi

#
# The next should only apply to apache servers.
#
if [ -f $save_dir/cgi-bin_ks.tar.gz ]; then
	mkdir -p /fnal/ups/prd/httpd/
	cd /fnal/ups/prd/httpd/
	chown 4652.5022 /fnal/ups/prd/httpd/
	tar xzf $save_dir/cgi-bin_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cgi-bin_ks.tar.gz ]; then
	mkdir -p /fnal/ups/prd/httpd/
	cd /fnal/ups/prd/httpd/
	chown 4652.5022 /fnal/ups/prd/httpd/
	tar xzf $backup_dir/cgi-bin_ks.tar.gz ${tar_opt}
	#Note: the directories to /fnal/ups/prd/httpd/cgi-bin/enstore
	#      should be owned by 4652.5022.  The files contained therein
	#      should be owned by 5146.5022.
fi

# /usr/local/bin
if [ "$type" == "srv" ]; then
	mkdir -p /usr/local/bin
	copy_it $pulldown_dir/rpcfix.pl /usr/local/bin
	copy_it $pulldown_dir/find.rpc /usr/local/bin
fi

# /usr/lib/mirror (for ADIC)
if [ -d $save_dir/mirror ]; then
	copy_it $save_dir/mirror /usr/lib
	ln -s /usr/lib/mirror/mirror.pl /usr/bin/mirror
fi


copy_it /local/ups/prd/ups/v4_7_2/Linux-2/init.d/ups /etc/rc.d/init.d/

cd /etc/rc.d/rc6.d/
ln -s ../init.d/ups K01ups
cd /etc/rc.d/rc3.d
ln -s ../init.d/ups S99ups

echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/shutdown/$hostname.products
echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
echo "ups start ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/startup/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/startup/$hostname.products

rm /home/enstore/*.fnal.gov.startup #Remove old copies...
touch /home/enstore/$hostname.fnal.gov.startup
chown 5744.6209 /home/enstore/$hostname.fnal.gov.startup


%post
#
#Finally, we are done with this.
#
umount /mnt/backup
/bin/rm -r /mnt/backup


%post
((
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
# Turning services on and off.
#
echo "  Turning services on and off." | tee -a /tmp/save/kickstart.log
/sbin/chkconfig autofs off
/sbin/chkconfig netfs off
/sbin/chkconfig netlock off
/sbin/chkconfig xfs on
/sbin/chkconfig ftp off
/sbin/chkconfig eklogin on
/sbin/chkconfig klogin on
/sbin/chkconfig kshell on
/sbin/chkconfig telnet on
/sbin/chkconfig netperf on
/sbin/chkconfig yum off
/sbin/chkconfig isdn off
/sbin/chkconfig pcmcia off
/sbin/chkconfig portmap on
/sbin/chkconfig mdmonitor off
/sbin/chkconfig mdmpd off
/sbin/chkconfig apmd off
/sbin/chkconfig rhnsd off
rm -f /etc/cron.daily/00-logwatch
rm -f /etc/cron.daily/0anacron
rm -f /etc/cron.daily/yum.cron
if [ "$type" == "mvr" -o "$type" == "dm" ]; then
   # We need to worry about this for dCache nodes.  It appears that the
   # head node and monitor node (door node too?) have sendmail enabled,
   # but pool nodes do not.  In the meantime, only Enstore servers
   # get sendmail turned on.

   /sbin/chkconfig sendmail off
   rm -f /etc/mail/submit.*
fi
if [ "$type" == "srv" -a "$number" -eq 3 ]; then
   /sbin/chkconfig iptables on
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Try putting the user and groups for users root and enstore to see if
# su really can work if these files are correct.  The installed versions
# should be correct, these only put information into the install environment.
#
grep "^enstore" /mnt/sysimage/etc/passwd >> /etc/passwd
grep "^root" /mnt/sysimage/etc/group >> /etc/group
grep "^enstore" /mnt/sysimage/etc/group >> /etc/group

%post
#
# Enstore home area stuff.
#
#
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
source /usr/local/etc/setups.sh
#
#
echo "  Beginning enstore home area stuff." | tee -a /tmp/save/kickstart.log
id enstore | tee -a /tmp/save/kickstart.log
( if [ "1" ]; then
	#
	#checkout enstore and ipmi
	#
	echo "Beginning cvs checkouts for enstore and ipmi."
	#grep "enstore" /etc/passwd  #does user enstore exist?
	export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
	export CVS_RSH=/usr/krb5/bin/rsh
	mkdir -p /home/enstore
	cd /home/enstore

	short_hostname=`echo $hostname | cut -f 1 -d "."`
	krb5_principal="enstore/cd/${short_hostname}.fnal.gov@FNAL.GOV"
	if [ ! -s /home/enstore/.k5login ]; then
	   #If we don't have an enstore .k5login file, create a temporary
	   # one for getting kinit to work.
	   echo "$krb5_principal" > /home/enstore/.k5login
	fi

	echo /usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal
	/usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal

	if [ -d /home/enstore/enstore ]; then
		cd /home/enstore/enstore
		cvs update -r production
	else
		cd /home/enstore
		cvs checkout -r production enstore
	fi
	if [ -d /home/enstore/ipmi ]; then
		cd /home/enstore/ipmi
		cvs update ipmi
	else
		cd /home/enstore
		cvs checkout ipmi
	fi
	#The installing of PyGreSQL needs to go after krb5.keytab, enstorekt
	# et. al. are in place.
	if [ "$type" == "srv" -o "$type" == "pnfs" ]; then
	   # eagpnfs1 and cmspnfs1 should work!
	   if [ "$number" -eq 0 -o "$number" -eq 1 -o "$number" -eq 2 \
		 -o "$number" -eq 3  -o "$number" -eq 6 ]; then
		 #
		 #This is yucky.  Need a better source of PyGreSQL.
		 #
		 cd /home/enstore
		 export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
		 export CVS_RSH=/usr/krb5/bin/rsh
		 cvs checkout PyGreSQL-3.6.2
		 setup python
		 setup postgres
		 cd /home/enstore/PyGreSQL-3.6.2
		 python setup.py build
		 python setup.py install
	   fi
	fi
	if [ "$type" == "pnfs" -o "$type" == "dca" \
		 -o "$type" == "srv" -a "$number" == "1" ]; then
	   if [ -d /home/enstore/dcache-deploy/dcache-fermi-config ]; then
	      cd /home/enstore/dcache-deploy/dcache-fermi-config
	      cvs update
	   else
	      mkdir -p /home/enstore/dcache-code
	      cd /home/enstore/dcache-code
	      cvs checkout dcache-fermi-config
	      cd /home/enstore
	      ln -s /home/enstore/dcache-code/ dcache-deploy
	   fi
	fi
fi 2>&1 ) | tee -a /tmp/save/kickstart.log
if [ -d /home/enstore/enstore ]; then
	#
	#build enstore and ipmi
	#
	echo "Beginning ftt, enstore and ipmi builds." | tee -a /tmp/save/kickstart.log
	((
	cd /fnal/ups/prd/ftt/v2_25/Linux-2-4
	export FTT_DIR=/fnal/ups/prd/ftt/v2_25/Linux-2-4
	make all
	cd /home/enstore/enstore/modules
	make clean
	setup enstore
	make
	cd /home/enstore/ipmi
	make
	) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
if [ -d /home/enstore/enstore ]; then
	#
	# Begin copying the following files to their needed locations.
	#
	echo "Copying enstore files to their needed locations." | tee -a /tmp/save/kickstart.log

	if [ "$type" == "srv" -o "$type" == "mvr" -o "$type" == "pnfs" ]; then
		copy_it /home/enstore/enstore/bin/enstore-boot /etc/rc.d/init.d
		chown 0.0 /etc/rc.d/init.d/enstore-boot
		ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc3.d/S99zzzenstore-boot
		ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc6.d/K01aaaenstore-boot
		copy_it /home/enstore/enstore/bin/monitor_server-boot /etc/rc.d/init.d
		chown 0.0 /etc/rc.d/init.d/monitor_server-boot
		ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc3.d/S99zzzmonitor_server-boot
		ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc6.d/K01aaamonitor_server-boot
	fi
	if [ "$type" == "pnfs" -o "$type" == "srv" -a "$number" == "1" ]; then


		#append the following kernel tunning paramaters.
		(
		echo
		echo "# Increase amount of shared memory up to 256MB."
		echo "kernel.shmmax=268435456"
		echo "kernel.shmall=268435456"
		) >> /etc/sysctl.conf
	fi
	if [ "$type" == "srv" ]; then
	   if [ "$number" -eq 0 ]; then
	      copy_it /home/enstore/enstore/sbin/enstore-db /etc/rc.d/init.d
	      chown 0.0 /etc/rc.d/init.d/enstore-db
	      ln -s /etc/rc.d/init.d/enstore-db /etc/rc.d/rc3.d/S99zzxenstore-db
	      ln -s /etc/rc.d/init.d/enstore-db /etc/rc.d/rc6.d/K01aaaenstore-db
	   elif [ "$number" -eq 6 ]; then
	      copy_it /home/enstore/enstore/sbin/enstore-pgdb /etc/rc.d/init.d
	      chown 0.0 /etc/rc.d/init.d/enstore-pgdb
	      ln -s /etc/rc.d/init.d/enstore-pgdb /etc/rc.d/rc3.d/S99zzzenstore-pgdb
	      ln -s /etc/rc.d/init.d/enstore-pgdb /etc/rc.d/rc6.d/K01aaaenstore-pgdb
	      copy_it /home/enstore/enstore/sbin/enstore-drivestat /etc/rc.d/init.d
	      chown 0.0 /etc/rc.d/init.d/enstore-drivestat
	      ln -s /etc/rc.d/init.d/enstore-drivestat /etc/rc.d/rc3.d/S99zzzenstore-drivestat
	      ln -s /etc/rc.d/init.d/enstore-drivestat /etc/rc.d/rc6.d/K01aaaenstore-drivestat
	   fi
	fi
	copy_it /home/enstore/enstore/etc/enstore.bashrc /home/enstore/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /home/enstore/.bash_profile
	#Where do the root/.bashrc and root/.bash_profile files come from?
	copy_it /home/enstore/enstore/etc/enstore.bashrc /root/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /root/.bash_profile
	copy_it /home/enstore/enstore/etc/sudoers /etc/
	chmod 0440 /etc/sudoers
	chown 0.0 /etc/sudoers
	# new copies to satisfy netscan
	copy_it /home/enstore/enstore/etc/services /etc/services
	mkdir -p /etc/X11/xinit
	copy_it /home/enstore/enstore/etc/xserverrc /etc/X11/xinit/xserverrc
	copy_it /home/enstore/enstore/etc/xinetd.conf /etc/xinetd.conf
	#
	copy_it /home/enstore/enstore/sbin/routes /root/
	chown 0.0 /root/routes
	copy_it /home/enstore/enstore/etc/products.k5login /local/ups/.k5login
	chown 1342.4525 /local/ups/.k5login
	chmod 0664 /local/ups/.k5login
	if [ -n $system ]; then
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/root.k5login.m4 > /tmp/root.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/root.k5login /root/.k5login
			chown 0.0 /root/.k5login
		fi
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/$system.enstore.k5login.m4 > /tmp/enstore.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/enstore.k5login /home/enstore/.k5login
			chown 5744.6209 /home/enstore/.k5login
		fi
		copy_it /home/enstore/enstore/etc/$system.hosts.allow /etc/hosts.allow
		chown 0.0 /etc/hosts.allow
		copy_it /home/enstore/enstore/etc/$system.step-tickers /etc/ntp/step-tickers
		chown 0.0 /etc/ntp/step-tickers
	fi
	copy_it /home/enstore/enstore/etc/hosts /etc/hosts
	chown 0.0 /etc/hosts
	copy_it /home/enstore/enstore/etc/ups /etc/rc.d/init.d/ups
	chown 0.0 /etc/rc.d/init.d/ups
	copy_it /home/enstore/enstore/etc/ntp.conf /etc/ntp.conf
	chown 0.0 /etc/ntp.conf
	copy_it /home/enstore/enstore/etc/services /etc/services
	chown 0.0 /etc/services
	copy_it /home/enstore/enstore/etc/krb5.conf /etc/krb5.conf
	chown 0.0 /etc/krb5.conf
	mkdir /var/ngop /var/ngop/include /var/ngop/cron_agent /var/ngop/plugins_agent
	copy_it "/home/enstore/enstore/ngop/*.py" /var/ngop/include
	copy_it /home/enstore/enstore/ngop/raise_enstore_alarm /var/ngop/include
	copy_it /home/enstore/enstore/ngop/local_cronjob.xml /var/ngop/cron_agent
	copy_it /home/enstore/enstore/ngop/start_cron /var/ngop/cron_agent/.start
	chmod 0755 /var/ngop/cron_agent/.start
	if [ "$type" == "mvr" ]; then
		copy_it /home/enstore/enstore/ngop/linuxHealth.xml /var/ngop/plugins_agent/
	elif [ "$type" == "srv" ]; then
		copy_it /home/enstore/enstore/ngop/srv_linuxHealth.xml /var/ngop/plugins_agent/
	fi
	((
	setup enstore
	/home/enstore/enstore/sbin/farmlets -f
	) 2>&1 ) | tee -a /tmp/save/kickstart.log
	chown -R 0.0 /var/ngop
	rm -f /home/enstore/enstore/tmp/enstore/*
	echo "" | tee -a /tmp/save/kickstart.log
	echo "end of enstore home stuff" | tee -a /tmp/save/kickstart.log
fi
if [ -d /home/enstore/dcache-deploy ]; then
   ((
   cd /home/enstore/dcache-deploy/dcache-fermi-config
   ln -s ../classes .
   ln -s ../config .
   #Copy over the dcache-boot file for this node.
   copy_it /home/enstore/dcache-deploy/dcache-fermi-config/$system/${hostname}-dcache-boot /etc/rc.d/init.d
   chown 0.0 /etc/rc.d/init.d/dcache-boot
   chmod 0755 /etc/rc.d/init.d/dcache-boot
   cd /etc/rc.d/rc3.d
   ln -s ../init.d/dcache-boot S99zzzdcache-boot
   cd /etc/rc.d/rc6.d
   ln -s ../init.d/dcache-boot K01aaadcache-boot
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
if [ "$type" == "pnfs" -o "$type" == "srv" -a "$number" == "1" ]; then
   ((
   copy_it /home/enstore/dcache-deploy/dcache-fermi-config/pnfs /etc/rc.d/init.d
   #copy_it /home/enstore/dcache-deploy/dcache-fermi-config/postgres-boot /etc/rc.d/init.d
   chown 0.0 /etc/rc.d/init.d/pnfs
   chmod 0555 /etc/rc.d/init.d/pnfs
   cd /etc/rc.d/rc3.d
   ln -s ../init.d/pnfs S94pnfs
   cd /etc/rc.d/rc6.d
   ln -s ../init.d/pnfs k94pnfs
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi

#) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
#
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
((
echo ""
echo " Last Few Things "
#  Setup the root and enstore .forward files.
echo "enstore-admin@fnal.gov" > /root/.forward
echo "enstore-admin@fnal.gov" > /home/enstore/.forward
#  Some versions of ftt have these files without execute permissions.
chmod +x /local/ups/prd/ftt/v2_22/Linux-2-4-2-3-2/etc/*
touch PRODUCTION
chmod 0644 PRODUCTION
mkdir -p /root/CRON
chmod 0755 /root/CRON
#  Set these permissions...
chown -R 5744.6209 /home/enstore
chown -R 5744.6209 /local/ups/kt/
chmod 0775 /fnal/ups/db
chmod 0775 /fnal/ups/prd
chmod 0775 /fnal/ups/db/.upsfiles/startup/${hostname}.products
chmod 0775 /fnal/ups/db/.upsfiles/shutdown/${hostname}.products
#Make the dir for mounting the backup directory.
mkdir /backup
chmod 0755 /backup
#Make the pnfs directories.
for item in `grep -v "$\#" /etc/fstab | awk '{print $2}' | grep pnfs | tr '\n' ' '`; do
    if [ ! -d $item ]; then
       echo "Making $item"
       mkdir -p $item
    fi
done
#
# Make mountpoint for any raid arrays.
#
echo ""
echo " mountpoint Things "
if [ -f /tmp/diska ]; then
       echo "Making /diska"
       mkdir -p /diska
fi
if [ -f /tmp/diskb ]; then
       echo "Making /diskb"
       mkdir -p /diskb
fi
if [ -f /tmp/diskc ]; then
       echo "Making /diskc"
       mkdir -p /diskc
fi
#
# for NFS
#
echo ""
echo " RQUOTAD Things "
if [ "$type" == "srv" -a "$number" == "3" ]; then
       echo "RQUOTAD=no" >> /etc/sysconfig/network
fi
#
echo ""
echo " PNFS Things "
# for PNFS
#
if [ "$type" == "srv" -a "$number" == "1" -o "$type" == "pnfs" ]; then
       #Make the configuration file so postgres knows where to look for the
       # database files.
       mkdir -p /etc/sysconfig/pgsql
       echo "PGDATA=/diska/pnfs/db/psql-data" > /etc/sysconfig/pgsql/postgresql
       #Set PNFS to start on boot.
       cd /etc/rc.d/rc3.d
       ln -s ../init.d/postgresql S91postgresql
fi
#
# Do the following for the nodes to talk to the console server.
#
setserial=`find /usr/share/doc/ -name rc.serial | grep "/rc.serial$" | sort | uniq | tail -n 1`
copy_it $setserial /etc/rc.d/init.d/serial
/usr/sbin/serialconsole_all
#
# For console server nodes.
#
if [ -f /etc/conserver.cf ]; then
   #We want to do this becuase we have version Y and not version Z.
   yum remove zz_conserver_cyc-z
   rm /etc/rc.d/init.d/load-cyc-z-fw
fi

) 2>&1 ) | tee -a /tmp/save/kickstart.log
