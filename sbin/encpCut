#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# sbin/$RCSfile$  $Revision$

# script to cut the encp (client) and enstore (server) products from the enstore cvs sources

# based on copCut which is based almost entirely on Ron R's dscCut

productCut=`basename $0`
echo "$productCut starting at `date`"
thepwd=`pwd`

##############################################################################
# utility functions that do what their names imply

# this function would be better if it actually did the command too, this
# would allow you to say "check_status command" rather than "command; check_status $? command.."
# Oh, well... next time
check_status() { jstatus=${1:-0}
                 jname=${2:-unknown}
                 jstep=${Step:-unknown}
                 if [ $jstatus != 0 ] ; then
                   echo ""
                   echo "$productCut Fatal Error=$1 \"$jname\", Step \"$jstep\"" >&2
                   echo "$productCut ABORTED at `date`"
                   cd $thepwd
                   exit $jstatus
                 else
                   if [ -z "${3-}" ] ; then
                      echo "$productCut success for \"$jname\", Step \"$jstep\" at `date`" >&2
                   fi
                 fi ; }

echo_timed_read() { jtime=${1:-10}
                    /bin/sh -c '( sleep '$jtime' ; kill $$ ) >/dev/null 2>&1 &
                    read ans ; echo "$ans"' ;}

starting() { if [ $try != "list" ] ; then
                /bin/echo -n "starting at `date`"
             fi; }

copyit()   { dname=`dirname $2`
             if [ ! -d $dname ]; then
               mkdir -p $dname
               check_status $? "mkdir -p $dname"
             fi
             cp $1 $2;
             check_status $? "cp $1 $2"; }

##############################################################################

USAGE="

   $productCut -options

-r version   next release version
-i directory install directory (without version number and product) for the new revision (i.e. /p/Linux)
-c chain     to set chain to be <new|old|test|development|current|none>
-s steps     to control which steps get executed,  zB 1,2,4-13
-x           to set -xv
-?           to list this

Steps to the cutting process:
  1.  cvs directory check
  2.  bump encp version number in encp.py
  3.  cd modules - make clean all
  4.  cd src - make clean encp
  5.  cd volume_import - make clean enstore_tape
  6.  cd doc/WWW - make all
  7.  compileall python source
  8.  cvs tag
  9.  install into product area
 10.  ups undeclare
 11.  ups declare
 12.  upd delproduct
 13.  upd addproduct
"

STEPSDEFINED=13

echo "$USAGE"

##############################################################################

product=`echo $productCut | sed -e 's/Cut//'`

if [ $product = "encp" ]; then
  productmate=enstore
  productUps=""
elif [ $product = "enstore" ]; then
  productmate=encp
  productUps="/ups"
else
  check_status 1 "Do not know anything about $productCut"
fi

##############################################################################

# we need ups and upd to be setup

if [ -z "${UPS_DIR-}" ] ; then
  Step="ups check"
  check_status 1 "You need ups to be setup before using $productCut"
fi

if [ -z "${UPD_DIR-}" ] ; then
  Step="upd check"
  check_status 1 "You need upd to be setup before using $productCut"
fi

##############################################################################
# we need enstore to be setup and we need to be in a cvs working directory

if [ -z "${ENSTORE_DIR-}" ] ; then
  Step="enstore check"
  check_status 1 "You need enstore to be setup before using $productCut"
fi
cd $ENSTORE_DIR
check_status $? "cd $ENSTORE_DIR"
FLAVOR=`echo $SETUP_ENSTORE | sed -e 's/.*-f //' -e 's/ .*//'`
if [ -d CVS ] ; then
   Cvs_Module=`expr "\`cat CVS/Repository\`" : ".*/\([^/]*\)"`
fi
if [ "${Cvs_Module:-}" = "" ];then
   check_status 1 "You need to be in a cvs working directory to use $productCut"
fi

##############################################################################
# parse the options on the command line
#### dadburned getopts does not work on OSF1, so parse opts manually############

gotc=

opt=""
if [ $# -gt 0 ] ; then
   for optarg in $@ ; do

      case $opt in
         -i) INSTALLDIR=$optarg
             opt=""
             ;;
         -r) REV=$optarg
             opt=""
             ;;
         -c) case $optarg in
               "")  CHAIN="";             ;;
               no*) CHAIN="";             ;;  # no or none
               c*)  CHAIN="${CHAIN-} -c"; ;;  # you can have multiple chains
               d*)  CHAIN="${CHAIN-} -d"; ;;
               n*)  CHAIN="${CHAIN-} -n"; ;;
               o*)  CHAIN="${CHAIN-} -o"; ;;
               t*)  CHAIN="${CHAIN-} -t"; ;;
                *)   Step="chain getopts"; check_status 1 "You have specified an illegal chain";  ;;
             esac
             gotc=1
             opt=""
             ;;
         -s) STEPS=`for i in \`echo $optarg | sed -e 's/,/ /g'\` ; do
                if x=\`expr $i : '\(.*\)-'\` ; then
                   y=\`expr $i : '.*-\(.*\)'\`
                   while [ $x -le $y -a $x -le $STEPSDEFINED ] ; do
                     echo $x
                     x=\`expr $x + 1\`
                   done
                else
                   echo $i
                fi
              done | sort -nu`        # do not sort if we want to specify an order or repeating steps (could use uniq instead of sort)
              STEPS="`echo $STEPS`"   # remove lfs (b/c STEPS isnt quoted inside)
              opt=""
              ;;
         "") opt=$optarg;;
         -?) echo "$USAGE"; Step="getopts"; check_status 1 "" ;;
         *)  echo "$USAGE"; Step="getopts"; check_status 1 "Unknown option" ;;
         esac
   done
fi

if [ -n "$opt" ] ; then echo "$USAGE"; Step="getopts"; check_status 1 "Can not parse command line correctly"; fi

echo ""
echo "options have been processed... checking"

##############################################################################
# we need a revision - if not specified, get old one from a cvs tag

if [ -z "${REV-}" ] ; then
   Step="next revision"
   last=`cvs status -v Makefile | grep \(revision: | egrep "$product|$productmate" | head -1  | sed -e 's/^[ ]*//'`
   check_status $? "cvs status -v Makefile"
   if [ -z "${last-}" ] ; then
     echo "revision info not available via cvs - defaulting to v0_0 as last known revision"
     last=${last:-v0_0_Linux}
   fi
   major=`echo $last | awk -F_ '{print $1}'`
   minor=`echo $last | awk -F_ '{print $2}'`
   REV=${major}_`expr $minor + 1`
   check_status $? "determining next rev from $last"
   echo "Revision not specified - Defaulting to revison $REV"
fi
TAG=${REV}_${product}_`uname`

##############################################################################
# we need a place to install the cut product

setrev=1
puntUPS=0
if [ -z "${INSTALLDIR-}" ] ; then
   Step="installdir"
   case `uname -n` in
      airedale*) INSTALLDIR=/home/products/$product;;
      pcfarm9*)  INSTALLDIR=/products/$product;;
      hppc*)     INSTALLDIR=/usr/products/IRIX+6/$product;;
      ripsgi*)   INSTALLDIR=/usr/products/$product;;
      rip8*)     INSTALLDIR=/fnal/ups/prd/$product/${REV}/Linux+2
                 setrev=0;;
      d0ola*)    INSTALLDIR=/home/bakken/enstore/$product #this stinks! but I don't know what else to do
		 FLAVOR="OSF1+V4"
	         puntUPS=1;;
      *)         check_status 1 "Don't know where to install ups product $product on `uname -n`";;
   esac
   echo "Install directory not specified - Defaulting to install directory of $INSTALLDIR"
fi
if [ $setrev -eq 1 ]; then
  INSTALLDIR=${INSTALLDIR}/${REV}
fi

##############################################################################
# we need to know what steps we are supposed to perform during the cut

if [ -z "${STEPS-}" ] ; then
   STEPS=1
   s=2
   while [ $s -le $STEPSDEFINED ] ; do STEPS="${STEPS-} $s"; s=`expr $s + 1`; done
   echo "Cut steps not specified - Defaulting to all steps: $STEPS"
fi
STEPSOK=""
for step in $STEPS; do
   if [ $step -le $STEPSDEFINED -a $step -ge 1 ] ; then
      if [ -z "${STEPSOK-}" ] ; then
        STEPSOK=$step
      else
        STEPSOK="$STEPSOK $step"
      fi
   fi
done
if [ -z "${STEPSOK-}" ] ; then
  Step="checksteps"
  check_status 1 "No steps defined, how odd"
fi
STEPS=$STEPSOK
STEPS="$STEPS done" # done is flag that we are finished
save_STEPS=$STEPS

##############################################################################
# we need to know what chain we are cutting

if [ -z "${gotc-}" ] ; then
   CHAIN=" -c"
   echo "UPS/UPD chain not specified - Defaulting to chain $CHAIN"
fi

echo ""
echo "Using files in CVS $Cvs_Module working directory `pwd` to cut $product $REV"
echo "  and ups/upd declaring it as ($CHAIN) into directory $INSTALLDIR using steps $save_STEPS."

##############################################################################

for try in list doit; do
   echo ""
   STEPS=$save_STEPS
   while [ "$STEPS" != "done" ] ; do
      Step="`expr \"$STEPS\" : '\([^ ]*\) .*'`"
      STEPS="`expr \"$STEPS\" : '[^ ]* \(.*\)'`"
      case $Step in

        1) echo "Step $Step:   cvs directory check for `pwd`    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR
              check_status $? "cd $ENSTORE_DIR"
              cvs_nq_update=`cvs -nq update 2>&1`
              check_status $? "cvs -nq update: $cvs_nq_update"
              if echo "$cvs_nq_update" | fgrep '[server aborted]' >/dev/null ; then
                check_status 1 "server aborted problems with cvs: $cvs_nq_update"
              elif x="`echo \"$cvs_nq_update\"|grep '^M'`"   ; then
               check_status 1 "$x: Modified or unknown files ($cvs_nq_update) in working directory - update/commit needed first"
              elif x="`echo \"$cvs_nq_update\"|grep '^[PU]'`"; then
               check_status 1 "$x: Update/Patched files ($cvs_nq_update) in repository - update/commit needed first"
              fi
           fi
           ;;

        2) echo "Step $Step:   bump encp version number to $REV in encp.py   `starting`"
           if [ "$try" = "doit" ] ; then
              encpnew=/tmp/$productCut.encpnew
              sed -e "s+version_string = \".*  CVS +version_string = \"$REV  CVS +" $ENSTORE_DIR/src/encp.py > $encpnew
              check_status $? "sed bump version to $REV"
              diff $ENSTORE_DIR/src/encp.py $encpnew
              cp $encpnew $ENSTORE_DIR/src/encp.py
              check_status $? "mv $encpnew $ENSTORE_DIR/src/encp.py"
              rm -f $encpnew
              cd $ENSTORE_DIR/src
              check_status $? "cd $ENSTORE_DIR/src"
              cvs commit -m "bumping version to $REV because of $productCut" encp.py
              check_status $? "cvs commit of encp.py"
           fi
           ;;

        3) echo "Step $Step:   cd modules and make clean all   `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/modules
              check_status $? "cd $ENSTORE_DIR/modules"
              make clean all
              check_status $? "make clean all"
           fi
           ;;

        4) echo "Step $Step:   cd src and make clean encp    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/src
              check_status $? "cd $ENSTORE_DIR/src"
              make clean encp
              check_status $? "make clean encp"
           fi
           ;;

        5) echo "Step $Step:   cd volume_import and make clean enstore_tape    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/volume_import
              check_status $? "cd $ENSTORE_DIR/volume_import"
              make clean enstore_tape
              check_status $? "make clean enstore_tape"
           fi
           ;;

        6) echo "Step $Step:   cd doc/WWW - make all    `starting`"
           if [ "$try" = "doit" ] ; then
              if [ $product = "enstore" ]; then
              cd $ENSTORE_DIR/doc
              check_status $? "cd $ENSTORE_DIR/volume_import"
              make clean all
              check_status $? "docs make clean all"
              else
                 echo "No make needed for documentation of encp"
              fi
           fi
           ;;

        7) echo "Step $Step:   compileall python source   `starting`"
           if [ "$try" = "doit" ] ; then
             find $ENSTORE_DIR -name "*\.pyc" | xargs rm
             check_status $? "rm of old pyc files"
             compileall_output=/tmp/$productCut.compileall_output
             python -c '
import os,compileall
compileall.compile_dir(os.environ["ENSTORE_DIR"])
' 2>&1 | tee $compileall_output
             check_status $? "compileall python source"
             if [ `grep -c "SyntaxError" $compileall_output` -ne 0 ]; then
               check_status 1 "compile error - see $compileall_output"
             else
               rm -f $compileall_output
             fi
           fi
           ;;

        8) echo "Step $Step:   cvs tag $TAG    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR
              check_status $? "cd $ENSTORE_DIR"
              cvs tag $TAG
              check_status $? "cvs tag $TAG"
           fi
           ;;

        9) echo "Step $Step:   install $product into $INSTALLDIR    `starting`"
           if [ "$try" = "doit" ] ; then
              # check if directory doesn't exist
              if [ ! -d $INSTALLDIR ] ; then
                 echo "$INSTALLDIR does not exist... making it"
                 mkdir -p $INSTALLDIR
                 check_status $? "mkdir -p $INSTALLDIR"
              else
                 rm -fr $INSTALLDIR
                 check_status $? "protections bad??  rm -fr $INSTALLDIR"
              fi

              if [ $product = "encp" ]; then

                copyit $ENSTORE_DIR/src/ENCPBIN/encp            $INSTALLDIR/encp
                copyit $ENSTORE_DIR/src/ENCPBIN/enstore         $INSTALLDIR/enstore
                copyit $ENSTORE_DIR/volume_import/enstore_tape  $INSTALLDIR/enstore_tape
                copyit $ENSTORE_DIR/bin/pnfs                    $INSTALLDIR/pnfs
                copyit $ENSTORE_DIR/bin/pnfs_common             $INSTALLDIR/pnfs_common
                copyit $ENSTORE_DIR/sbin/EPS                    $INSTALLDIR/EPS
                copyit $ENSTORE_DIR/ups/encp.table              $INSTALLDIR/encp.table
                copyit $ENSTORE_DIR/ups/rip.table               $INSTALLDIR/rip.table
                copyit $ENSTORE_DIR/ups/sam.table               $INSTALLDIR/sam.table
                cd $INSTALLDIR
                check_status $? "cd $INSTALLDIR"
                ln -s sam.table enstore_variables.table
                check_status $? "ln -s sam.table enstore_variables.table"
                manifest=$INSTALLDIR/.encpCut.manifest

              elif [ $product = "enstore" ]; then

                copylist=/tmp/$productCut.copylist
                find $ENSTORE_DIR/ -type f| egrep -v "/CVS|/templates|\.o$|\~$|\.#|.cvsignore|/test/[0-9]+|/test/data|core|enstore_variables.table">$copylist
                check_status $? "find files > $copylist"
                if [ -z "${cvs_nq_update-}"]; then
                  cvs_nq_update=`cvs -nq update 2>&1`
                  check_status $? "cvs -nq update"
                fi
                cat $copylist | while read from; do
                    to=`echo $from | sed -e "s#^$ENSTORE_DIR/##"`
                    if [ "$to" = "$from" ]; then
                       check_status 1 "can't get to from from $to $from"
                    fi
                    if x="`echo \"$cvs_nq_update\"|grep \"^? $to\"`"; then
                        echo "Skipping $to because it is not in the repository"
                    else
                      copyit $from $INSTALLDIR/$to
                    fi
                done
                rm -f $copylist
                cd $INSTALLDIR/ups
                check_status $? "cd $INSTALLDIR/ups"
                ln -s sam.table enstore_variables.table
                check_status $? "ln -s sam.table enstore_variables.table"
                cd $INSTALLDIR/bin
                check_status $? "cd $INSTALLDIR/bin"
                ln -s ../src/encp.py encp
                check_status $? "ln -s ../src/encp.py encp"
                ln -s ../src/enstore_admin.py enstore
                check_status $? "ln -s ../src/enstore_admin.py enstore"
                cd $INSTALLDIR/sbin
                check_status $? "cd $INSTALLDIR/sbin"
                ln -s encpCut enstoreCut
                check_status $? "ln -s encpCut enstoreCut"
                manifest=$INSTALLDIR/ups/.encpCut.manifest
             fi

             filelist=/tmp/$productCut.filelist
             find $INSTALLDIR -type f > $filelist
             check_status $? "find $INSTALLDIR -type f > $filelist"
             cat $filelist | while read f; do
               s=`sum $f`
               check_status $? "s=`sum $f`" quiet
               echo $f $s >>$manifest
               check_status $? "echo $f $s >>$manifest" quiet
             done
             rm -f $filelist
             set | grep _DIR= | egrep -v "export|EMACS|ISPELL"| sort >>$manifest

             find $INSTALLDIR -type d | xargs chmod 555
             check_status $? "find $INSTALLDIR -type d | xargs chmod 555"
             find $INSTALLDIR -type f | xargs chmod -w
             check_status $? "find . -type f | xargs chmod -w"
             chmod 555 $INSTALLDIR
             check_status $? "chmod 555 $INSTALLDIR"

             if [ $puntUPS -eq 1 ]; then
	        rm -f ~/$product_$REV.tar
		tar -cf ~/$product_$REV.tar $INSTALLDIR
                check_status $? "tar -cf ~/$product_$REV.tar $INSTALLDIR"
             fi
           fi
           ;;

       10) echo "Step $Step:  ups undeclare -f $FLAVOR $product $REV    `starting`"
           if [ "$try" = "doit" ] ; then
	      if [ $puntUPS -ne 1 ]; then
                a=`$UPS_DIR/bin/ups undeclare  -f $FLAVOR $product $REV 2>&1`
                stat=$?
                if [ `echo "$a" | grep -c "No matching product"` -eq 0 ]; then
                  check_status $stat $a
                fi
	      else
                echo "PUNTING: ups undeclare  -f $FLAVOR $product $REV" 
              fi
           fi
           ;;

       11) echo "Step $Step:  ups declare $CHAIN -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV    `starting`"
           if [ "$try" = "doit" ] ; then
	      if [ $puntUPS -ne 1 ]; then
                 $UPS_DIR/bin/ups declare $CHAIN -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV
                 check_status $? "ups declare"
	      else
                 echo "PUNTING: ups declare $CHAIN -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV"
              fi
           fi
           ;;

       12) echo "Step $Step:  upd delproduct -H $FLAVOR -f $FLAVOR  $product $REV   `starting`"
           if [ "$try" = "doit" ] ; then
	      if [ $puntUPS -ne 1 ]; then
                a=`$UPD_DIR/bin/upd delproduct  -H $FLAVOR -f $FLAVOR $product $REV 2>&1`
                stat=$?
                if [ `echo "$a" | grep -c "No matching product"` -eq 0 ]; then
                  check_status $stat $a
                fi
              else
 	        echo "PUNTING: upd delproduct  -H $FLAVOR -f $FLAVOR $product $REV"
              fi
           fi
           ;;

       13) echo "Step $Step:  upd addproduct $CHAIN -H $FLAVOR -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV   `starting`"
           if [ "$try" = "doit" ] ; then
	      if [ $puntUPS -ne 1 ]; then
                $UPD_DIR/bin/upd addproduct $CHAIN -H $FLAVOR -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV
                check_status $? "upd addproduct"
	      else
	        echo "PUNTING:upd addproduct $CHAIN -H $FLAVOR -f $FLAVOR -r $INSTALLDIR -M ${INSTALLDIR}${productUps} -m $product.table $product $REV"
              fi 
           fi
           ;;


        *) check_status 1 "There is no step \"$Step\". Why did you ask for it?"
           ;;

       esac
   done

   if [ "$try" = "list" ] ; then
      /bin/echo -n "\nThere are a total of $STEPSDEFINED steps defined. Is this the set that you want to do? "
      ans=`echo_timed_read 10`
      if [ $? != 0 ] || expr "$ans" : '[Yy]' >/dev/null ; then
        echo "Proceeding with $productCut..."
        echo ""
    else
         cd $thepwd
         check_status $? "cd $thepwd"
         exit 0
      fi
  fi
done

cd $thepwd
echo "$productCut $REV finished at `date`"
